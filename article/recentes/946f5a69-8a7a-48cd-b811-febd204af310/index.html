<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>How we’re making GitHub Copilot smarter with fewer tools | Re:Notícias</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.9.4/css/bulma.min.css">
    <style>
        html {
            height: 100%;
        }

        body {
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            margin: 0;
        }

        main {
            flex-grow: 1;
        }
    </style>
    <script defer src="https://use.fontawesome.com/releases/v5.15.4/js/all.js"></script>
</head>
<body>

    <nav class="navbar is-light" role="navigation" aria-label="main navigation">
  <div class="container">
    <div class="navbar-brand">
      <a class="navbar-item" href="https://drakeshin.github.io/renoticia.github.io/">
        <strong class="is-size-4">Re:Notícias</strong>
      </a>

      <a role="button" class="navbar-burger" aria-label="menu" aria-expanded="false" data-target="navbarMenuPrincipal">
        <span aria-hidden="true"></span>
        <span aria-hidden="true"></span>
        <span aria-hidden="true"></span>
      </a>
    </div>

    <div id="navbarMenuPrincipal" class="navbar-menu">
      <div class="navbar-start">
        
          
            <a class="navbar-item" href="/renoticia.github.io/esportes/">
              Esportes
            </a>
          
        
          
            <a class="navbar-item" href="/renoticia.github.io/saude/">
              Saúde
            </a>
          
        
          
            <a class="navbar-item" href="/renoticia.github.io/negocios/">
              Negócios
            </a>
          
        
      </div>
    </div>
  </div>
</nav>

    <main>
        
<section class="section">
  <div class="container">
    <div class="columns is-centered">
      <div class="column is-three-quarters">

        
        <h1 class="title is-2 has-text-centered mb-5">
          How we’re making GitHub Copilot smarter with fewer tools
        </h1>

        
        <div class="level is-mobile mb-4">
          <div class="level-left">
            <div class="level-item">
              <p class="subtitle is-6 has-text-grey">
                <time datetime=" 2025-11-19T20:00:00Z">
                  Publicado em 19/11/2025 às 20:00
                </time>
              </p>
            </div>
          </div>

          
          <div class="level-right">
            <div class="level-item">
              
              <a href="https://github.blog/ai-and-ml/github-copilot/how-were-making-github-copilot-smarter-with-fewer-tools/" target="_blank" class="button is-small is-primary is-outlined">
                Ver Fonte Original
              </a>
            </div>
          </div>
          
        </div>

        <hr>

        
        <div class="content is-medium">
          
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html><body><p>In VS Code, GitHub Copilot Chat can access hundreds of tools through the Model Context Protocol (MCP) that range from codebase analysis tools to Azure-specific utilities. But giving an agent too many tools&nbsp;doesn&rsquo;t&nbsp;always make it smarter. Sometimes it just makes it slower.&nbsp;</p>



<p>If you&rsquo;ve ever seen this spinner in VS Code, you&rsquo;ve hit the limits of a model that&rsquo;s trying to reason across too many tools at once.</p>



<figure class="wp-block-image size-full"><img data-recalc-dims="1" decoding="async" width="385" height="60" src="https://github.blog/wp-content/uploads/2025/11/tool-selection.png?resize=385%2C60" alt='Screenshot of a spinner next to the words "Optimizing tool selection..."' class="wp-image-92458" srcset="https://github.blog/wp-content/uploads/2025/11/tool-selection.png?w=385 385w, https://github.blog/wp-content/uploads/2025/11/tool-selection.png?w=300 300w" sizes="(max-width: 385px) 100vw, 385px" /></figure>



<p>To fix that,&nbsp;we&rsquo;ve&nbsp;built two new systems&mdash;embedding-guided tool routing and adaptive tool clustering&mdash;and&nbsp;we&rsquo;re&nbsp;rolling out&nbsp;a reduced toolset that trims the default 40 built-in tools down to 13 core ones. Across benchmarks like SWE-Lancer and&nbsp;SWEbench-Verified with both GPT-5 and Sonnet 4.5, these changes improve success rates by&nbsp;2-5 percentage&nbsp;points. In online A/B testing,&nbsp;it&nbsp;reduces&nbsp;response&nbsp;latency&nbsp;by&nbsp;an average of&nbsp;400&nbsp;milliseconds.&nbsp;&nbsp;</p>



<h2 class="wp-block-heading" id="h-too-many-tools-impede-agent-intelligence-nbsp-nbsp">Too many tools impede agent intelligence&#8239;&nbsp;&nbsp;</h2>



<p>The default toolset in VS Code consists of about 40 built-in tools,&nbsp;ranging from&nbsp;general&nbsp;command-line utilities to&nbsp;specialized tools for&nbsp;Jupyter&nbsp;Notebooks. With MCP servers included, that number can grow into&nbsp;the hundreds. Often, MCP servers bring in so many tools that they can exceed the&nbsp;API&nbsp;limits of some models.&nbsp;&nbsp;</p>



<p>We&rsquo;ve&nbsp;explored ways to filter down our toolset to&nbsp;provide&nbsp;only&nbsp;the tools&nbsp;most&nbsp;relevant to&nbsp;the&nbsp;user&rsquo;s query, while not restricting&nbsp;the agent&rsquo;s&nbsp;capabilities.&nbsp;Specifically, we needed to make sure we&nbsp;didn&rsquo;t&nbsp;sacrifice the user&rsquo;s experience to achieve lower latency.&nbsp;</p>



<p>To&nbsp;accomplish&nbsp;this, we&nbsp;designed a middle-ground approach: &ldquo;virtual tools.&rdquo; This includes functionally grouping similar tools under one &ldquo;virtual tool&rdquo; the chat agent can expand as needed. Think of these as directories that&nbsp;contain&nbsp;related tools. This gives the model a general sense of&nbsp;what&rsquo;s&nbsp;available without flooding it with hundreds of tool names.&nbsp;It&nbsp;also reduces&nbsp;the&nbsp;cache miss rate&nbsp;we&rsquo;d&nbsp;expect if the model searched for individual tools, since&nbsp;it&rsquo;s&nbsp;likely that similar tools are used and activated together.&nbsp;&nbsp;</p>



<h2 class="wp-block-heading" id="h-applying-lossless-dynamic-tool-nbsp-selection-nbsp-for-mcp-tools-nbsp-nbsp">Applying lossless dynamic tool&nbsp;selection&nbsp;for MCP tools&nbsp;&nbsp;</h2>



<h3 class="wp-block-heading" id="h-adaptive-tool-clustering-nbsp-nbsp">Adaptive tool clustering&nbsp;&nbsp;</h3>



<p>Initially we&nbsp;fed all the available tools into an LLM and asked&nbsp;it&nbsp;to group and summarize them. But this had two big issues:&nbsp;&nbsp;&nbsp;</p>



<ul class="wp-block-list">
<li>We&nbsp;couldn&rsquo;t&nbsp;control the number of groups created, and it sometimes exceeded model limits&nbsp;&nbsp;&nbsp;</li>



<li>It was extremely slow and incurred a huge token cost. The model would also sometimes &lsquo;forget&rsquo; to categorize certain tools, forcing retries&nbsp;&nbsp;</li>
</ul>



<p>To tackle this issue, we applied&nbsp;<a href="https://github.blog/news-insights/product-news/copilot-new-embedding-model-vs-code/" target="_blank" rel="noreferrer noopener">our internal Copilot embedding model optimized for semantic similarity tasks</a>&nbsp;to generate embeddings for each tool and group them using cosine similarity. This clustering method allowed precise, stable, and reproducible groups. As an example, here is one&nbsp;possible grouping&nbsp;of embeddings for the GitHub MCP server&rsquo;s tools&nbsp;in the embedding space:&nbsp;&nbsp;</p>



<figure class="wp-block-image size-large"><img data-recalc-dims="1" fetchpriority="high" decoding="async" height="512" width="1024" src="https://github.blog/wp-content/uploads/2025/11/tool-use.png?resize=1024%2C512" alt="A clustering chart showing groupings of embeddings for the GitHub MCP server's tools: create_pending_pull_request_review, get_issue_comments, create_branch, get_me, and list_tags." class="wp-image-92459" srcset="https://github.blog/wp-content/uploads/2025/11/tool-use.png?w=2400 2400w, https://github.blog/wp-content/uploads/2025/11/tool-use.png?w=300 300w, https://github.blog/wp-content/uploads/2025/11/tool-use.png?w=768 768w, https://github.blog/wp-content/uploads/2025/11/tool-use.png?w=1024 1024w, https://github.blog/wp-content/uploads/2025/11/tool-use.png?w=1536 1536w, https://github.blog/wp-content/uploads/2025/11/tool-use.png?w=2048 2048w" sizes="(max-width: 1000px) 100vw, 1000px" /></figure>



<p>We still use a model call to summarize each cluster, but this step is much faster and cheaper than asking the model to categorize everything from scratch. Tool embeddings and group summaries are&nbsp;cached&nbsp;locally, so recomputing them is comparatively cheap.&nbsp;&nbsp;</p>



<h2 class="wp-block-heading" id="h-context-guided-tool-nbsp-selection-nbsp-nbsp">Context-guided tool&nbsp;selection&nbsp;&nbsp;</h2>



<p>Once tools were grouped, we faced another problem: how does the model know which group to open without checking them all?&nbsp;We saw that,&nbsp;most of the time, the model would&nbsp;<em>eventually&nbsp;</em>find the right tool for its task. However, each call to a virtual tool still results in a&nbsp;cache&nbsp;miss, an extra round trip, and an opportunity for a small percentage of agent operations to fail.&nbsp;</p>



<p>For example, when the user says:&nbsp;<em>&ldquo;Fix this bug and merge it into the dev branch.&rdquo;</em>&nbsp;</p>



<p>The model often opens&nbsp;<strong>search tools</strong>, then&nbsp;<strong>documentation tools</strong>, then&nbsp;<strong>local Git tools</strong>, before finally realizing that it actually needs the&nbsp;<strong>merge tool inside the GitHub MCP tool group</strong>&nbsp;to complete the operation.&nbsp;</p>



<p>Each incorrect group lookup adds latency and overhead, even though the correct group is fairly obvious from the context.&nbsp;</p>



<p>To address this, we introduced&nbsp;<strong>Embedding-Guided Tool Routing</strong>. Before any tool group is expanded, the system compares the query embedding against vector representations of all tools (and their clusters), allowing it to pre-select the most semantically relevant candidates&mdash;even if&nbsp;they&rsquo;re&nbsp;buried deep inside a group.&nbsp;</p>



<p>With context-aware routing, we can infer from the beginning that the model is&nbsp;very likely&nbsp;to need the&nbsp;<em>merge tool</em>&nbsp;inside the GitHub MCP tool&nbsp;group, and&nbsp;include it directly in its candidate set&mdash;eliminating&nbsp;unnecessary exploratory calls and significantly reducing latency and failure rates.&nbsp;<br>&nbsp;<br>By surfacing only the most promising matches, we make the&nbsp;model&rsquo;s&nbsp;search more targeted and reliable, while reducing redundant exploration.&nbsp;</p>



<h2 class="wp-block-heading" id="h-embedding-based-selection-powered-by-nbsp-the-nbsp-copilot-nbsp-embedding-model-nbsp-nbsp">Embedding-based selection (powered by&nbsp;the&nbsp;Copilot&nbsp;Embedding model)&nbsp;&nbsp;</h2>



<p>We&nbsp;calculate&nbsp;the success of our embedding-based selection process via&nbsp;<strong>Tool Use Coverage,</strong>&nbsp;which&nbsp;measures how often the model already has the right tool visible when it needs it.&nbsp;</p>



<p>In benchmarks, the embedding-based approach achieved 94.5% Tool Use Coverage,&nbsp;outperforming both LLM-based&nbsp;selection&nbsp;(87.5%) and&nbsp;the default static tool list (69.0%).&nbsp;&nbsp;</p>



<p><strong>Offline</strong>, this approach resulted in a 27.5% absolute improvement in coverage, clearly surpassing the LLM-based method while helping the agent reason faster and stay efficient.&nbsp;&nbsp;</p>



<p><strong>Online testing</strong>&nbsp;shows the same pattern: only&nbsp;<strong>19%</strong>&nbsp;of Stable tool calls were successfully pre-expanded using the old method,&nbsp;whereas&nbsp;<strong>72%</strong>&nbsp;of Insiders tool calls were pre-expanded thanks to&nbsp;the embedding-based matching. This confirms that the gains&nbsp;observed&nbsp;offline are consistently reflected in real-world usage.&nbsp;</p>



<figure class="wp-block-image size-large"><img data-recalc-dims="1" decoding="async" height="538" width="1024" src="https://github.blog/wp-content/uploads/2025/11/HumanEvalInfilling_1200x630.png?resize=1024%2C538" alt="A bar graph showing coverage rates. Embedding based is highest with 94.5%, followed by GPT-4.1 based at 87.5% and Default tools at 69%." class="wp-image-92482" srcset="https://github.blog/wp-content/uploads/2025/11/HumanEvalInfilling_1200x630.png?w=2400 2400w, https://github.blog/wp-content/uploads/2025/11/HumanEvalInfilling_1200x630.png?w=300 300w, https://github.blog/wp-content/uploads/2025/11/HumanEvalInfilling_1200x630.png?w=768 768w, https://github.blog/wp-content/uploads/2025/11/HumanEvalInfilling_1200x630.png?w=1024 1024w, https://github.blog/wp-content/uploads/2025/11/HumanEvalInfilling_1200x630.png?w=1536 1536w, https://github.blog/wp-content/uploads/2025/11/HumanEvalInfilling_1200x630.png?w=2048 2048w" sizes="(max-width: 1000px) 100vw, 1000px" /></figure>



<h2 class="wp-block-heading" id="h-less-is-more-shrinking-the-default-toolset-nbsp-nbsp">Less is more: shrinking the default toolset&#8239;&nbsp;&nbsp;</h2>



<p>Even without hitting the model limits that massive MCP servers can trigger, an oversized built-in toolset still degrades performance.&nbsp;In offline benchmarks, we&nbsp;observed&nbsp;a&nbsp;2&ndash;5&nbsp;percentage point decrease&nbsp;in&nbsp;resolution rate on benchmarks including SWE-Lancer&nbsp;when&nbsp;the agent had access to the full built-in toolset.&nbsp;Behaviorally, the&nbsp;agent ends up&nbsp;ignoring explicit instructions, using tools incorrectly, and calling tools that are unnecessary to the task at&nbsp;hand.&nbsp;&nbsp;</p>



<p>So, we trimmed the list. Based on tool usage statistics and performance data, we&nbsp;identified&nbsp;a core toolset of 13 essential tools. These tools encompass&nbsp;high-level&nbsp;repository structure&nbsp;parsing,&nbsp;file reading and editing, context searching,&nbsp;and&nbsp;terminal&nbsp;usage.&nbsp;&nbsp;</p>



<p>The remaining, non-core&nbsp;built-in tools are grouped into four virtual categories:&nbsp;Jupyter&nbsp;Notebook Tools, Web Interaction Tools, VS Code Workspace Tools, and Testing Tools. This way, the model sees the smaller core set up-front and can expand groups only if necessary.&nbsp;As a result,&nbsp;users with the shrunken toolset experience&nbsp;an average decrease of 190 milliseconds in&nbsp;TTFT (Time&nbsp;To&nbsp;First Token),&nbsp;and&nbsp;an average decrease of&nbsp;400&nbsp;milliseconds in TTFT (Time to Final Token, or time to complete model response).</p>



<p>A smaller toolset enables the agent to be more effective:&nbsp;simpler reasoning, faster response times, and better performance.&nbsp;&nbsp;</p>



<h2 class="wp-block-heading" id="h-future-directions-from-tool-nbsp-selection-nbsp-to-long-context-reasoning-nbsp-nbsp">Future directions: from tool&nbsp;selection&nbsp;to long-context reasoning&nbsp;&nbsp;</h2>



<p>As MCP systems evolve, the challenge&nbsp;isn&rsquo;t&nbsp;just&nbsp;picking&nbsp;the right tool&mdash;it&rsquo;s&nbsp;reasoning across time, context, and interactions.&nbsp;&nbsp;&nbsp;</p>



<p>A truly intelligent model&nbsp;shouldn&rsquo;t&nbsp;just react to queries; it should&nbsp;<em>remember&nbsp;previous&nbsp;tool usage, infer intent from history, and plan multi-step actions</em>&nbsp;over long sessions.&nbsp;In this sense, tool&nbsp;selection&nbsp;is an early form of long-context reasoning. The same mechanisms that help models route to the right tool today could, in the future, help them reason across thousands of&nbsp;turns&nbsp;helping them decide when to act, when to delegate, and when to stop.&nbsp;&nbsp;&nbsp;</p>



<p>Our next step is to explore how embeddings, memory, and reinforcement signals can combine to create context-aware agents that learn&nbsp;<em>how</em>&nbsp;to use tools, not just&nbsp;<em>which</em>&nbsp;ones to pick.</p>



<div class="wp-block-group post-content-cta has-global-padding is-layout-constrained wp-block-group-is-layout-constrained">
<p><strong>Want to see how Copilot uses MCP tools in action?</strong> <a href="https://github.com/features/copilot/?utm_source=blog-vs-code-updates&amp;utm_medium=blog&amp;utm_campaign=universe25post">Try GitHub Copilot now &gt;</a></p>
</div>



<p class="is-typography-preset-h3"><strong>Acknowledgments&nbsp;</strong>&nbsp;</p>



<p>A big shoutout to our developer community for continuing to give us feedback and push us to deliver the best possible&nbsp;agent&nbsp;experiences with GitHub Copilot. A huge thanks also to <a href="https://www.linkedin.com/in/zijianjin/">Zijian Jin</a>, a researcher on the team who helped to write this blog&mdash;and to the researchers, engineers, product managers across VS Code and GitHub Copilot&nbsp;for&nbsp;this work.&nbsp;&nbsp;(Also: We&rsquo;re hiring applied researchers and software engineers, so feel free to apply!)</p>



<p></p>
</body></html>
<p>The post <a href="https://github.blog/ai-and-ml/github-copilot/how-were-making-github-copilot-smarter-with-fewer-tools/">How we’re making GitHub Copilot smarter with fewer tools</a> appeared first on <a href="https://github.blog">The GitHub Blog</a>.</p>

        </div>

        
        
        <div class="mt-6">
          <a href="/renoticia.github.io/recentes/" class="button is-light is-link">
            
            &larr; Voltar para a lista de Recentes
          </a>
        </div>
        

      </div>
    </div>
  </div>
</section>

    </main>

    <footer class="footer">
      <div class="content has-text-centered">
        <p>
          &copy; 2025 Re:Notícias.
        </p>
      </div>
    </footer>

    <script src="https://drakeshin.github.io/renoticia.github.io/js/navbar.js"></script>
</body>
</html>